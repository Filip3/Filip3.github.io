<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C# 9.0 on Malenko</title>
    <link>/tags/c#-9.0/</link>
    <description>Recent content in C# 9.0 on Malenko</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 24 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/c#-9.0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>So Many IOptions</title>
      <link>/posts/so-many-ioptions/</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/so-many-ioptions/</guid>
      <description>The bigger the options toolbelt, the more power we have. What is one of our main goals when working on a solution? Isn&amp;rsquo;t it to provide simplicity, decoupling and separation to a certain degree, that it will not overcomplicate our solution but keep the code clean enough to not be sullied by all sorts of overhead requirements. And this is always a balance that we are trying to achieve. This enables us to focus on solving domain problems, instead of us looking at code that can be convoluted with all sorts of none domain-related structural requirements.</description>
    </item>
    
    <item>
      <title>Why Not Records</title>
      <link>/posts/why-records-c-sharp/</link>
      <pubDate>Thu, 04 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/why-records-c-sharp/</guid>
      <description>Glimpsing into the functional world from within the old world Why does this intrigue me and it should probably maybe spark something in you. Well C# has been around for ages, as F# and other functional languages and approaches. But it was never so much in demand as it is today. Or it might just be my current perspective and my exposure to my technical social circle. What this means, simplification of the way we present the world we see in our codebase.</description>
    </item>
    
  </channel>
</rss>
